"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _path = require("path");

var _mkdirp = require("mkdirp");

var _fs = require("fs");

var _chokidar = _interopRequireDefault(require("chokidar"));

var _chalk = _interopRequireDefault(require("chalk"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _reactRouterConfig = require("react-router-config");

var _getRouteConfig = _interopRequireDefault(require("./routes/getRouteConfig"));

var _stripJSONQuote = _interopRequireDefault(require("./routes/stripJSONQuote"));

var _routesToJSON = _interopRequireDefault(require("./routes/routesToJSON"));

var _requestCache = require("./requestCache");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = require('debug')('umi:FilesGenerator');

class FilesGenerator {
  constructor(service) {
    this.service = service;
    this.routesContent = null;
    this.hasRebuildError = false;
    this.layoutDirectoryName = service.config.singular ? 'layout' : 'layouts';
  }

  generate(opts = {}) {
    const paths = this.service.paths;
    const absTmpDirPath = paths.absTmpDirPath,
          tmpDirPath = paths.tmpDirPath;
    debug(`Mkdir tmp dir: ${tmpDirPath}`);
    (0, _mkdirp.sync)(absTmpDirPath);
    this.generateFiles();
    if (opts.onChange) opts.onChange();
  }

  createWatcher(path) {
    const watcher = _chokidar.default.watch(path, {
      ignored: /(^|[\/\\])\../,
      // ignore .dotfiles
      ignoreInitial: true
    });

    watcher.on('all', (0, _lodash.default)((event, path) => {
      debug(`${event} ${path}`);
      this.rebuild();
    }, 100));
    return watcher;
  }

  watch() {
    if (process.env.WATCH_FILES === 'none') return;
    const paths = this.service.paths;
    const watcherPaths = this.service.applyPlugins('modifyPageWatchers', {
      initialValue: [paths.absPagesPath, (0, _path.join)(paths.absSrcPath, '_routes.json'), ..._constants.EXT_LIST.map(ext => (0, _path.join)(paths.absSrcPath, `${this.layoutDirectoryName}/index${ext}`))]
    });
    this.watchers = watcherPaths.map(p => {
      return this.createWatcher(p);
    });
    process.on('SIGINT', () => {
      this.unwatch();
    });
  }

  unwatch() {
    if (this.watchers) {
      this.watchers.forEach(watcher => {
        watcher.close();
      });
    }
  }

  rebuild() {
    const devServer = this.service.devServer;

    try {
      this.service.applyPlugins('generateFiles', {
        args: {
          isRebuild: true
        }
      });
      this.generateRouterJS();
      this.generateEntry();
      if (this.onChange) this.onChange();

      if (this.hasRebuildError) {
        // 从出错中恢复时，刷新浏览器
        devServer.sockWrite(devServer.sockets, 'content-changed');
        this.hasRebuildError = false;
      }
    } catch (e) {
      // 向浏览器发送出错信息
      devServer.sockWrite(devServer.sockets, 'errors', [e.message]);
      this.hasRebuildError = true;
      this.routesContent = null; // why?

      debug(`Generate failed: ${e.message}`);
      debug(e);
      console.error(_chalk.default.red(e.message));
    }
  }

  generateEntry() {
    const _this$service = this.service,
          paths = _this$service.paths,
          entryJSTpl = _this$service.entryJSTpl,
          config = _this$service.config,
          libraryName = _this$service.libraryName; // Generate umi.js

    let entryContent = (0, _fs.readFileSync)(entryJSTpl || paths.defaultEntryTplPath, 'utf-8');
    entryContent = this.service.applyPlugins('modifyEntryFile', {
      initialValue: entryContent
    });
    entryContent = entryContent.replace(_constants.PLACEHOLDER_IMPORT, '').replace(_constants.PLACEHOLDER_HISTORY_MODIFIER, '').replace(/<%= libraryName %>/g, libraryName).replace(_constants.PLACEHOLDER_RENDER, `ReactDOM.render(React.createElement(require('./router').default), document.getElementById('root'));`);

    if (!config.disableServiceWorker) {
      entryContent = `${entryContent}
// Enable service worker
if (process.env.NODE_ENV === 'production') {
  require('./registerServiceWorker');
}
      `;
    }

    (0, _fs.writeFileSync)(paths.absLibraryJSPath, entryContent, 'utf-8');
  }

  generateFiles() {
    const _this$service2 = this.service,
          paths = _this$service2.paths,
          config = _this$service2.config;
    this.service.applyPlugins('generateFiles');
    this.generateRouterJS();
    this.generateEntry(); // Generate registerServiceWorker.js

    if (process.env.NODE_ENV === 'production' && !config.disableServiceWorker) {
      (0, _fs.writeFileSync)(paths.absRegisterSWJSPath, (0, _fs.readFileSync)(paths.defaultRegisterSWTplPath), 'utf-8');
    }
  }

  generateRouterJS() {
    const _this$service3 = this.service,
          paths = _this$service3.paths,
          config = _this$service3.config;
    const absRouterJSPath = paths.absRouterJSPath;
    const routes = this.service.applyPlugins('modifyRoutes', {
      initialValue: (0, _getRouteConfig.default)(paths, config)
    });
    this.service.setRoutes(routes);
    const routesContent = this.getRouterJSContent(); // 避免文件写入导致不必要的 webpack 编译

    if (this.routesContent !== routesContent) {
      (0, _fs.writeFileSync)(absRouterJSPath, routesContent, 'utf-8');
      this.routesContent = routesContent;
    }
  }

  getRouterJSContent() {
    const _this$service4 = this.service,
          routerTpl = _this$service4.routerTpl,
          paths = _this$service4.paths,
          libraryName = _this$service4.libraryName;
    const routerTplPath = routerTpl || paths.defaultRouterTplPath;
    (0, _assert.default)((0, _fs.existsSync)(routerTplPath), `routerTpl don't exists: ${routerTplPath}`);
    let tplContent = (0, _fs.readFileSync)(routerTplPath, 'utf-8');
    tplContent = this.service.applyPlugins('modifyRouterFile', {
      initialValue: tplContent
    });
    let routes = this.getRoutesJSON({
      env: process.env.NODE_ENV,
      requested: (0, _requestCache.getRequest)()
    });
    routes = (0, _stripJSONQuote.default)(routes);
    const routerContent = this.service.applyPlugins('modifyRouterContent', {
      initialValue: this.getRouterContent()
    });
    return tplContent.replace(_constants.PLACEHOLDER_IMPORT, '').replace(_constants.PLACEHOLDER_ROUTER_MODIFIER, '').replace(_constants.PLACEHOLDER_ROUTES_MODIFIER, '').replace('<%= ROUTES %>', () => routes).replace(_constants.PLACEHOLDER_ROUTER, routerContent).replace(/<%= libraryName %>/g, libraryName);
  }

  getRequestedRoutes(requested) {
    return Object.keys(requested).reduce((memo, pathname) => {
      (0, _reactRouterConfig.matchRoutes)(this.service.routes, pathname).forEach(({
        route
      }) => {
        memo[route.path] = 1;
      });
      return memo;
    }, {});
  }

  fixHtmlSuffix(routes) {
    routes.forEach(route => {
      if (route.routes) {
        route.path = `${route.path}(.html)?`;
        this.fixHtmlSuffix(route.routes);
      }
    });
  }

  getRoutesJSON(opts = {}) {
    const env = opts.env,
          _opts$requested = opts.requested,
          requested = _opts$requested === void 0 ? {} : _opts$requested;
    const requestedMap = this.getRequestedRoutes(requested);
    return (0, _routesToJSON.default)(this.service.routes, this.service, requestedMap, env);
  }

  getRouterContent() {
    return `
<Router history={window.g_history}>
  <Route render={({ location }) =>
    renderRoutes(routes, {}, { location })
  } />
</Router>
    `.trim();
  }

}

exports.default = FilesGenerator;