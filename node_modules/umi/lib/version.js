"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _chalk = _interopRequireDefault(require("chalk"));

var path = _interopRequireWildcard(require("path"));

var _fs = require("fs");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(opts = {}) {
  let umiSameAsCore = [];

  const pkg = require(path.resolve(__dirname, '..', 'package.json'));

  let projPkg;

  try {
    projPkg = require(path.resolve(this.project.root, 'package.json'));
  } catch (exception) {
    projPkg = undefined;
  }

  const patterns = [/^@babel\/runtime$/, /^babel-preset-umi$/, /^umi-build-dev$/, /^umi-test$/];
  const nodeModules = findUp('node_modules', __dirname);
  const versions = [...Object.keys(pkg && pkg['dependencies'] || {}), ...Object.keys(pkg && pkg['devDependencies'] || {}), // Add all node_modules and node_modules/@*/*
  ...(0, _fs.readdirSync)(nodeModules).reduce((acc, name) => {
    if (name.startsWith('@')) {
      return acc.concat((0, _fs.readdirSync)(path.resolve(nodeModules, name)).map(subName => name + '/' + subName));
    } else {
      return acc.concat(name);
    }
  }, [])].filter(x => patterns.some(p => p.test(x))).reduce((acc, name) => {
    if (name in acc) {
      return acc;
    }

    acc[name] = getVersion(name, nodeModules);
    return acc;
  }, {});
  let umiVersion = pkg.version;

  if (!(pkg._from && pkg._resolved)) {
    umiVersion = '@local';
  }

  const namePad = ' '.repeat(Object.keys(versions).sort((a, b) => b.length - a.length)[0].length + 3);
  const asciiArt = `
  _    _  __  __  _____ 
 | |  | ||  \\/  ||_   _|
 | |  | || \\  / |  | |  
 | |  | || |\\/| |  | |  
 | |__| || |  | | _| |_ 
  \\____/ |_|  |_||_____|
   `.split('\n').map(x => _chalk.default.cyan(x)).join('\n');
  console.log(asciiArt);
  console.log(`
      Umi: ${umiVersion}
      Node: ${process.versions.node}
      OS: ${process.platform} ${process.arch}
      ... ${umiSameAsCore.sort().reduce((acc, name) => {
    // Perform a simple word wrap around 60.
    if (acc.length == 0) {
      return [name];
    }

    const line = acc[acc.length - 1] + ', ' + name;

    if (line.length > 60) {
      acc.push(name);
    } else {
      acc[acc.length - 1] = line;
    }

    return acc;
  }, []).join('\n... ')}

      Package${namePad.slice(7)}Version
      -------${namePad.replace(/ /g, '-')}------------------
      ${Object.keys(versions).map(module => `${module}${namePad.slice(module.length)}${versions[module]}`).sort().join('\n')}
    `.replace(/^ {6}/gm, ''));
}

function getVersion(moduleName, nodeModules) {
  try {
    if (nodeModules) {
      const modulePkg = require(path.resolve(nodeModules, moduleName, 'package.json'));

      return modulePkg.version;
    }
  } catch (_) {}

  return '<error> or <local>';
}

function findUp(names, from) {
  if (!Array.isArray(names)) {
    names = [names];
  }

  const root = path.parse(from).root;
  let currentDir = from;

  while (currentDir && currentDir !== root) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const name = _step.value;
        const p = path.join(currentDir, name);

        if ((0, _fs.existsSync)(p)) {
          return p;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    currentDir = path.dirname(currentDir);
  }

  return null;
}